<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제3장 어셈블의사문자</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 3 장 어셈블러 의사 문자(Assembler pseudo character)</FONT>
<BR>
<P><FONT SIZE=3>  GA에서는 의사 문자라 부르는 1바이트 혹은 2바이트 문자가 있는데, 레이블 선언 문자, 상수     선언 문자, 리스트 제어 문자, 주석 선언 문자, 2진수 선언 문자 16진수 선언 문자 그리고 편    집 문자 정의 등이 있다..</FONT>
<BR>
<P><FONT SIZE=3>  +-- 참고 ------------------------------------------------------------------------------+</FONT>
<P><FONT SIZE=3>  |의사 문자란?                                                                          |</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  |표준 어셈블러에서는 기계어 코드에는 영향을 미치지 안고 어셈블러에게 지시를 하는 명령  |</FONT>
<P><FONT SIZE=3>  |어를 '의사어'라고 한다.                                                               |</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  |(예) 번지 산출 의사어 'offset'                                                        |</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  |     mov ax,offset data                                                               |</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  |GA에서의 '의사 문자'는 '의사어'에 대응된다.  여기서 '문자'라는 의미는 위의 예처럼 'of |</FONT>
<P><FONT SIZE=3>  |fset'이라는 문자열이 아니고 단일 문자이기 때문이다.                                   |</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  |(예) 'offset'과 대응되는 의사 문자 '&amp;'                                                |</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  |     mov ax,&amp;data                                                                     |</FONT>
<P><FONT SIZE=3>  +--------------------------------------------------------------------------------------+</FONT>
<BR>
<P><FONT SIZE=3><B>  3.1 레이블 선언 의사 문자 </B></FONT>
<BR>
<P><FONT SIZE=3>  레이블 선언 의사 문자는 '_'(언더바)이다.  언더바로 정의된 이름은 레이블로 간주된다.  레    이블 선언 문자 뒤에 오는 문자의 길이가 20바이트를 넘으면 20바이트까지 인식되고 레이블      선언이 중복되어서는 안되며 레이블이름은 어느 문자나 상관없다.  GA에서는 레이블, 데이터     레이블, 프로시져의 개념은 없고 모두 하나의 레이블로 간주된다.</FONT>
<BR>
<P><FONT SIZE=3>  (예) _label1 : 레이블 'label1'을 선언</FONT>
<P><FONT SIZE=3>       _12345  : 레이블 '12345'를 선언(숫자도 상관없다.)</FONT>
<P><FONT SIZE=3>       _레이블 : 레이블 '레이블'을 선언(한글 레이블도 가능)</FONT>
<P><FONT SIZE=3>       _123456789012345678901 : 20바이트를 넘어 '12345678901234567890' 까지 인식</FONT>
<BR>
<P><FONT SIZE=3><B>  3.2 상수 선언 의사 문자</B></FONT>
<P><FONT SIZE=3>   </FONT>
<P><FONT SIZE=3>  상수 선언 의사 문자는 '!'(느낌표)이다.  느낌표가 정의된 이름은 상수로 간주된다.  상수 선    언 의사 문자 뒤에 오는 문자의 길이가 20바이트를 넘으면 20바이트까지 인식되고 상수 선언도    중복되어서는 안되며 상수 이름은 어느 문자나 문제없다.  GA에서의 상수 선언은 숫자만 허용    된다.</FONT>
<BR>
<P><FONT SIZE=3>  (예) !NULL</FONT>	<FONT SIZE=3>0 : 상수 'NULL'에 0을 선언</FONT>
<P><FONT SIZE=3>       !ENTER   0x0d : 상수 'ENTER'에 16진수 'd'를 선언</FONT>
<P><FONT SIZE=3>       !상수    0b11110000 : 상수 '상수'에 상수 0b11110000을 선언</FONT>
<P><FONT SIZE=3>       !123456789012345678901 -1 : 20바이트를 넘어 '12345678901234567890'에 -1을 선언</FONT>
<BR>
<P><FONT SIZE=3>  +-- 참고 ---------------------------------------------------------------------------+ </FONT>
<P><FONT SIZE=3>  |상수 선언 '(예)'에서 두 번째 줄에 0x0d는 16진수를 선언하는 것으로 3.6에서 설명된다.|</FONT>
<P><FONT SIZE=3>  +-----------------------------------------------------------------------------------+ </FONT>
<BR>
<P><FONT SIZE=3><B>  3.3 번지 산출 의사 문자</B></FONT>
<BR>
<P><FONT SIZE=3>  번지 산출 의사 문자는 '&amp;'(엠퍼샌드)이다.  정의된 레이블의 번지를 얻을 때 사용한다.  이것    은 표준 어셈블러의 'offset'수식어와 같은 기능을 한다.</FONT>
<BR>
<P><FONT SIZE=3>  (예) _abc mov ax,&amp;abc : 레이블 'abc'의 번지를 ax레지스터에 전송</FONT>
<P><FONT SIZE=3>       _msg dw &amp;abc : 레이블 'abc'의 번지를 값으로 함</FONT>
<BR>
<P><FONT SIZE=3> <B> 3.4 리스트 제어 의사 문자</B></FONT>
<BR>
<P><FONT SIZE=3>  리스트 제어 의사 문자는 '.'(마침표)이다. 의사 문자 뒤에 오는 리스트 제어 문은 모두 5가지    가 있다.</FONT>
<BR>
<P><FONT SIZE=3>  <B>3.4.1 liston/listoff(List On/Off)</B></FONT>
<BR>
<P><FONT SIZE=3>  리스트 제어 문의 가장 절대적인 것으로 모든 리스트 정보 출력을 허가 또는 금지한다.  초기    치는 liston으로 모든 리스트 정보를 표시한다.</FONT>
<BR>
<P><FONT SIZE=3><B>  3.4.2 linenumberon/linenumberoff(Line Number On/Off)</B></FONT>
<BR>
<P><FONT SIZE=3>  소스 행의 줄 번호 정보를 제어한다.  초기 치는 linenumberon으로 줄 번호를 표시한다.</FONT>
<BR>
<P><FONT SIZE=3><B>  3.4.3 offsetdisplayon/offsetdisplayoff(Offset Display On/Off)</B></FONT>
<BR>
<P><FONT SIZE=3>  각 명령어가 시작되는 번지의 표시를 제어한다.  초기 치는 offsetdisplayon으로 번지를 표시    한다.</FONT>
<BR>
<P><FONT SIZE=3><B>  3.4.4 binarycodedisplayon/binarycodedisplayoff(Binary Code Display On/Off)</B></FONT>
<BR>
<P><FONT SIZE=3>  어셈블되어진 기계어명령어의 표시를 제어한다.  초기치는 binarycodedisplayon으로 어셈된기    계 어를 표시한다.</FONT>
<BR>
<P><FONT SIZE=3><B>  3.4.5 commenton/commentoff(Comment On/Off)</B></FONT>
<BR>
<P><FONT SIZE=3>  소스화일에서 주석 문의 표시를 제어한다.  초기치는 commenton으로 주석이 있는 줄을 표시한    다. </FONT>
<BR>
<P><FONT SIZE=3>  +-- 참고 -----------------------------------------------------------------------------+</FONT>
<P><FONT SIZE=3>  |리스트 제어 문을 사용하면 리스트화일에 필요한 정보만을 표시할 수 있고 어셈블시간을 줄|</FONT>
<P><FONT SIZE=3>  |일수 있다.                                                                           |</FONT>
<P><FONT SIZE=3>  +-------------------------------------------------------------------------------------+</FONT>
<BR>
<P><FONT SIZE=3><B>  3.5 주석 선언 문자</B></FONT>
<BR>
<P><FONT SIZE=3>  주석 선언 문자는 ';'(세미콜론)이다.  세미콜론 뒤로 쓰이는 어떤 한 문자열도 어셈블러에      해 무시된다.</FONT>
<BR>
<P><FONT SIZE=3><B>  3.6 16진수 선언 문자</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>16진수 선언 문자는 '0x'이다.  16진수 선언 문자 뒤에 오는 것은 16진수로 인식되며 처음 '0    '을 제외한 문자가 4개를 넘으면 안된다.  선언 문자는 소문자 대문자를 구별하지 안다.</FONT>
<BR>
<P><FONT SIZE=3>  (예) 0x10 : 16진수 '10'을 선언</FONT>
<P><FONT SIZE=3>       0xff : 16진수 'ff'를 선언</FONT>
<P><FONT SIZE=3>       0xabcd : 16진수 'abcd'를 선언</FONT>
<P><FONT SIZE=3>       0xffff : 16진수 'ffff'를 선언</FONT>
<P><FONT SIZE=3>       0x0ffff : 16진수 'ffff'를 선언</FONT>
<P><FONT SIZE=3><B>       </B>0xfffff : 2바이트를 초과</FONT>
<P><FONT SIZE=3>  </FONT>
<P><FONT SIZE=3><B>  3.7 10진수 선언</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>10진수는 숫자를 그대로 사용하면 되면 마이너스 붙이면 음수로 인식된다.</FONT>
<BR>
<P><FONT SIZE=3><B>  3.8 2진수 선언 문자</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>2진수 선언 문자는 '0b'이다.  2진수 선언 문자 뒤에 오는 것은 2진수로 인식되며 처음 '0 '을    제외한 문자가 16개를 넘으면 안된다.</FONT>
<BR>
<P><FONT SIZE=3>  (예) 0b1111 : 이진수 '1111'을 선언</FONT>
<P><FONT SIZE=3>       0b11110000 : 이진수 '11110000'을 선언</FONT>
<P><FONT SIZE=3>       0b1111000011110000 : 이진수 '1111000011110000'을 선언</FONT>
<P><FONT SIZE=3>       0b00001111000011110000 : 이진수 '1111000011110000'을 선언</FONT>
<P><FONT SIZE=3>       0b10000111100001111 : 2바이트를 초과</FONT>
<BR>
<P><FONT SIZE=3>  <B>3.9 편집 문자 정의</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>편집 문자란 'C language'에서 제공하는 '\n','\r' 등을 의미한다.  GA에서는 표준 'C'와 같은    기능을 제공하며 1바이트로 간주된다.</FONT>
<BR>
<P><FONT SIZE=3>  </FONT>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=588 HEIGHT=43>
<TD VALIGN=MIDDLE WIDTH=7%>
<P><FONT SIZE=3>'\\'</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=12%>
<P><FONT SIZE=3>'\'자신</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=7%>
<P><FONT SIZE=3>'\0'</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=12%>
<P><FONT SIZE=3>NULL</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=7%>
<P><FONT SIZE=3>'\a'</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=12%>
<P><FONT SIZE=3>0x07</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=7%>
<P><FONT SIZE=3>'\b'</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=12%>
<P><FONT SIZE=3>0x08</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=7%>
<P><FONT SIZE=3>'\n'</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=12%>
<P><FONT SIZE=3>0x0a</FONT></TD>
<TR>
<TD VALIGN=MIDDLE WIDTH=7%>
<P><FONT SIZE=3>'\r'</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=12%>
<P><FONT SIZE=3>0x0d </FONT></TD>
<TD VALIGN=MIDDLE WIDTH=7%>
<P><FONT SIZE=3>'\t'</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=12%>
<P><FONT SIZE=3>0x09</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=7%>
<P><FONT SIZE=3>'"'</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=12%>
<P><FONT SIZE=3>0x22</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=7%>
<P><FONT SIZE=3>'''</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=12%>
<P><FONT SIZE=3>0x27</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=7%>
<BR></TD>
<TD VALIGN=MIDDLE WIDTH=12%>
<BR></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</TABLE>
<BR>
<P><FONT SIZE=3><B>  </B>(예) mov ah,'\r' : ah 레지스터에 0x0d를 전송</FONT>
<P><FONT SIZE=3>       ds  "GoldFish Assembler version 1.1\r\n" : 스트링끝에서 0x0d,0x0a로 변환된다.</FONT>
<BR>
<P><FONT SIZE=3>  +-- 참고 ---------------------------------------------------------------------+       </FONT>
<P><FONT SIZE=3>  |위의 (예)에 두 번째 줄에 'ds'명령어는 스트링 선언 명령어로 ??장에서 설명된다.| </FONT>
<P><FONT SIZE=3>  +-----------------------------------------------------------------------------+ </FONT>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제4장 프로그램작성규칙</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 4 장 프로그램 작성 규칙(Program syntax)</FONT>
<BR>
<P><FONT SIZE=3>  GA는 표준 어셈블러와 호환이 안되는 기술적인 부분과, 문법적인 부분이 있는데 단일 세그먼     트, 어셈블 수식어, 베이스 메모리에서 번지의 사용, 변화된 문법, 수치의 직접 입력, 대·소    문자 인식 등이 있다.</FONT>
<BR>
<P><FONT SIZE=3><B>  4.1 단일 세그먼트</B></FONT>
<BR>
<P><FONT SIZE=3>  GA는 다른 상업용 어셈블러가 지원하는 다중 세그먼트를 지원하지 않고 단일 세그먼트만을 지    원하며 생성되는 실행화일의 구조도 COM파일로 한정되고 프로그램 시작 주소를 반드시 '0x100'    으로 설정해야 한다.</FONT>
<BR>
<P><FONT SIZE=3>  +-- 번지를 0x100의로 지정하는 예 -+</FONT>
<P><FONT SIZE=3>  |;Program </FONT>	<FONT SIZE=3>start               |</FONT>
<P><FONT SIZE=3>  |</FONT>		<FONT SIZE=3>org</FONT>	<FONT SIZE=3>0x100       |</FONT>
<P><FONT SIZE=3>  |                                 |</FONT>
<P><FONT SIZE=3>  |</FONT>	<FONT SIZE=3>_start</FONT>	<FONT SIZE=3>mov</FONT>	<FONT SIZE=3>ah,9        |</FONT>
<P><FONT SIZE=3>  |</FONT>		<FONT SIZE=3>mov</FONT>	<FONT SIZE=3>dx,&amp;stg     |</FONT>
<P><FONT SIZE=3>  |</FONT>		<FONT SIZE=3>int</FONT>	<FONT SIZE=3>0x21        |</FONT>
<P><FONT SIZE=3>  |                                 |</FONT>
<P><FONT SIZE=3>  |</FONT>		<FONT SIZE=3>int</FONT>	<FONT SIZE=3>0x20        |</FONT>
<P><FONT SIZE=3>  |                                 |</FONT>
<P><FONT SIZE=3>  |_stg         db      "test$"     |</FONT>
<P><FONT SIZE=3>  +---------------------------------+</FONT>
<BR>
<P><FONT SIZE=3>  +-- 참고  ----------------------------------------------------------------------------+</FONT>
<P><FONT SIZE=3>  |위의 프로그램에서 'org'는 시스템 명령어로 프로그램의 번지를 강제로 지정하는 것으로 명|</FONT>
<P><FONT SIZE=3>  |령으로 뒤에서 설명된다.                                                              |</FONT>
<P><FONT SIZE=3>  +-------------------------------------------------------------------------------------+</FONT>
<P><FONT SIZE=3>                                                                                         </FONT>
<P><FONT SIZE=3>  <B>4.2 어셈블 수식어</B></FONT>
<BR>
<P><FONT SIZE=3>  어셈블 수식어로는 표준 어셈블러에서 제공하는 'byte','word','short','near','far'등이 있     다.  </FONT>
<BR>
<P><FONT SIZE=3><B>  4.2.1 byte</B></FONT>
<P><FONT SIZE=3>                                </FONT>
<P><FONT SIZE=3>  'byte'수식어는 베이스 메모리의 타입을 byte로 설정한다.  GA는 데이터를 정의할 때 데이타입    을 기억하지 안기 때문에 베이스 메모리를 사용할 때는 반드시 사용해야 한다.</FONT>
<BR>
<P><FONT SIZE=3>  (예) mov al,byte _stg</FONT>
<P><FONT SIZE=3>       mov byte _stg,ah</FONT>
<P><FONT SIZE=3>       mov byte _stg,1</FONT>
<BR>
<P><FONT SIZE=3><B>  4.2.2 word</B></FONT>
<BR>
<P><FONT SIZE=3>  'word'수식어는 베이스 메모리의 타입을 2바이트로 설정합니다.  GA는 데이터를 정의할 때 데    이터 타입을 기억하지 안기 때문에 베이스 메모리를 사용할 때는 반드시 사용해야 합니다.</FONT>
<BR>
<P><FONT SIZE=3>  (예) mov ax,word _stg</FONT>
<P><FONT SIZE=3>       mov word _stg,ax</FONT>
<P><FONT SIZE=3>       mov word _stg,1</FONT>
<BR>
<P><FONT SIZE=3><B>  4.2.3 short</B></FONT>
<BR>
<P><FONT SIZE=3>  'short'수식어는 jump를 하는 명령어의 수식어이다.  거리는 +127-(-128)바이트를 넘지 안는     범위이고 생성되는 코드는 2바이트이며 번지 산출 의사 문자(&amp;)를 사용해야 한다.</FONT>
<BR>
<P><FONT SIZE=3>  (예) je short &amp;abc</FONT>
<P><FONT SIZE=3>       jne short &amp;korea</FONT>
<P><FONT SIZE=3>       jmp short &amp;hwp</FONT>
<P><FONT SIZE=3>       loop short &amp;exit</FONT>
<P><FONT SIZE=3>       </FONT>
<P><FONT SIZE=3><B>  4.2.4 near</B></FONT>
<BR>
<P><FONT SIZE=3>  'near'수식어는 IP(Instruction Pointer : 명령 시작점)를 다시 세팅하여 jump하는 명령에서     사용된다.  'near'는 레이블 선언 의사 문자(_)와 번지 산출 의사 문자(&amp;)를 사용할 수 있다.    두 개의 차이점은 아래와 같다.</FONT>
<BR>
<P><FONT SIZE=3>  +- 레이블 선언 의사 문자와 번지 산출 의사 문자의 차이 ---------------------------------+</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  |     org  0x100                                                                       |</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  |</FONT>	<FONT SIZE=3>call near &amp;stg                                                                   |</FONT>
<P><FONT SIZE=3>  |</FONT>	<FONT SIZE=3>call near _stg                                                                   |</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  |_stg dw   0xabcd                                                                      |</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  |레이블 'stg'는 'org'명령으로 번지는 '0x1234'이며 그 번지에 있는 값은 '0xabcd'이다.    |</FONT>
<P><FONT SIZE=3>  |여기서 'call near &amp;stg'와 'call near _stg'는 다음과 같이 어셈블 된다.                 |</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  |     call near &amp;stg  --&gt;  call near 0x0107 : _stg로 call                              |</FONT>
<P><FONT SIZE=3>  |     call near _stg  --&gt;  call near [0x0107] : _stg번지에 있는 '0xabcd'로 call        |</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  +--------------------------------------------------------------------------------------+</FONT>
<BR>
<P><FONT SIZE=3><B>  4.2.5 far</B></FONT>
<BR>
<P><FONT SIZE=3>  'far'수식어는 CS(Code Segment)와 IP(Instruction Pointer)를 다시 세팅는 명령에서 사용된     다.  'far'는 두개의 오퍼랜드를 갖는 명령이나 베이스 메모리의 'far'선언시 사용된다.</FONT>
<BR>
<P><FONT SIZE=3>  (예) jmp far 0x1234,0xabcd</FONT>
<P><FONT SIZE=3>       jmp far [bx]</FONT>
<P><FONT SIZE=3>       call far _stg</FONT>
<BR>
<P><FONT SIZE=3><B>  4.3 베이스 메모리에서 번지의 사용</B></FONT>
<BR>
<P><FONT SIZE=3>  베이스 메모리의 변위에 레이블의 번지를 수치처럼 나타낼수 있다.  레이블을 수치로 나타낼때    는 반드시 번지 산출 의사 문자(&amp;)를 사용해야 한다.</FONT>
<BR>
<P><FONT SIZE=3>  (예) mov ax,word [bx+&amp;stg]</FONT>
<P><FONT SIZE=3>       mov byte [&amp;abc],ah</FONT>
<BR>
<P><FONT SIZE=3><B>  4.4 변화된 문법</B></FONT>
<BR>
<P><FONT SIZE=3><B>  4.4.1 사라진 'ptr'수식어</B></FONT>
<BR>
<P><FONT SIZE=3>  기존의 어셈블러에서는 'offset ptr'을 사용하였지만 GA는 'offset'을 '&amp;'로 대채하고 'ptr'을 </FONT>
<P><FONT SIZE=3>  배재하였다.</FONT>
<BR>
<P><FONT SIZE=3>  (예) mov ax,word &amp;stg</FONT>
<P><FONT SIZE=3>       mov byte _abc,ah</FONT>
<BR>
<P><FONT SIZE=3><B>  4.4.2 ':'문법의 변화</B></FONT>
<BR>
<P><FONT SIZE=3>  기존의 어셈블러에서는 far call을 할때 ':'으로 나타냈지만 GA에서는 2operand규칙을 준수하    여 2operand로 나타낸다.</FONT>
<BR>
<P><FONT SIZE=3>  (예) call far 0xabcd,0x1234</FONT>
<BR>
<P><FONT SIZE=3>  +-- 참고 -----------------------------------------------+</FONT>
<P><FONT SIZE=3>  |어셈블리 언어는 다음과 같은 문법구조를 가지고 있습니다.|</FONT>
<P><FONT SIZE=3>  |                                                       |</FONT>
<P><FONT SIZE=3>  |opcode 1operand,2operand                               |</FONT>
<P><FONT SIZE=3>  |                                                       |</FONT>
<P><FONT SIZE=3>  |GA에서는 위의 규칙을 준수하여 모든 문법을 정하였습니다.|</FONT>
<P><FONT SIZE=3>  +-------------------------------------------------------+</FONT>
<BR>
<P><FONT SIZE=3><B>  4.4.3 수치의 직접입력</B></FONT>
<BR>
<P><FONT SIZE=3>  GA는 재배치를 하지안는 대신 수치를 직접입력 할수있다.</FONT>
<BR>
<P><FONT SIZE=3>  (예) je short 0x100</FONT>
<P><FONT SIZE=3>       jne short 0x200</FONT>
<P><FONT SIZE=3>       call near 0xabcd</FONT>
<P><FONT SIZE=3>       call far 0x1234,0xabcd</FONT>
<BR>
<P><FONT SIZE=3><B>  4.5 대</B>·<B>소 문자 인식</B></FONT>
<BR>
<P><FONT SIZE=3>  GA는 대소문자를 인식하며 모든 명령어는 소문자로 작성되어야 한다.</FONT>
<BR>
<P><FONT SIZE=3>  (예) </FONT>	<FONT SIZE=3>ORG 0x100</FONT>
<BR>
<P><FONT SIZE=3>  위의 명령어를 어셈블하면 다음과 같은 오류 메시지가 표시됩니다.</FONT>
<BR>
<P><FONT SIZE=3>  Error : Not 8086/8087 operation code or system code</FONT>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제5장 a?? 명령어</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 5 장 a?? 명령어</FONT>
<BR>
<P><FONT SIZE=3>  <B>5.1 aaa(ASCII 덧셈의 결과를 조정한다)</B></FONT>
<BR>
<P><FONT SIZE=3>  [기능]</FONT>
<P><FONT SIZE=3>  al 레지스터의 하위 4비트의 내용이 0-9 사이에 있으면 AF 플래그를 0 으로 하고, al 레지       스터의 상위 4 비트는 0 으로 한다.  만약 al 레지스터의 하위 4 비트의 내용이 0x0a - 0x0f     이거나 AF 플래그가 1 이면 al 레지스터의 내용에 6 을 더하고 ah 레지스터의 내용에 1 을 더    한후 AF 플래그를 1 로 한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  aaa</FONT>
<BR>
<P><FONT SIZE=3><B>  5.2 aad(나눗셈을 위해 ax 레지스터를 조정한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  ah 레지스터와 al 레지스터에 언팩된 BCD 오퍼랜드가 들어 있을 경우, ah 레지스터의 내용에     0x0a 를 곱하고 ah 레지스터와 al 레지스터의 내용을 다한며 ah 레지스터에 0x00 를 저장한다.</FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[사용예]</FONT>
<P><FONT SIZE=3>  aad</FONT>
<P><FONT SIZE=3><B>  </B></FONT>
<P><FONT SIZE=3><B>  5.3 aam(BCD 수 곱셈의 결과를 조정한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  두 개의 언팩(unpack) BCD 수를 곱셈한 후, al 레지스터를 0x0a 로 나누어 ah 레지스터에 몫을    저장하고 나머지는 al 레지스터에 저장한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  aam</FONT>
<BR>
<P><FONT SIZE=3><B>  5.4 aas(ASCII 값 뺄셈의 결과를 조정한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  오퍼랜드로 2 개의 ASCII 문자를 뺀 후, al 레지스터의 하위 4 비트의 내용이 0-9 이고 AF 플    래그가 0 이면, al 레지스터의 상위 4 비트가 내용을 0 으로 하고, al 레지스터의 하위 4 비트    내용이 0x0a-0x0f 이거나 AF 플래그가 1 이면 al 레지스터의 내용에서 6 을 뺀 후 ah 레지스터    의 내용에서 1 을 빼고 AF 플래그를 1로 한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  aas</FONT>
<BR>
<P><FONT SIZE=3><B>  5.5 adc(캐리를 고려한 덧셈)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  1오퍼랜드,2오퍼랜드와 캐리플래그의 값을 더하여 1오퍼랜드에 저장한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  adc ax,bx</FONT>
<P><FONT SIZE=3>  adc ah,bh</FONT>
<P><FONT SIZE=3>  adc word _a,ax</FONT>
<P><FONT SIZE=3>  adc ax,word _a</FONT>
<P><FONT SIZE=3>  adc byte _a,al</FONT>
<P><FONT SIZE=3>  adc al,byte _a</FONT>
<P><FONT SIZE=3>  adc ax,1</FONT>
<P><FONT SIZE=3>  adc word _a,1</FONT>
<P><FONT SIZE=3>  adc byte _a,1</FONT>
<BR>
<P><FONT SIZE=3><B>  5.6 add(캐리를 고려하지 않은 덧셈)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  1오퍼랜드와 2오퍼랜드를 더하여 1오퍼랜드에 저장한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  add ax,bx</FONT>
<P><FONT SIZE=3>  add ah,bh</FONT>
<P><FONT SIZE=3>  add word _a,ax</FONT>
<P><FONT SIZE=3>  add ax,word _a</FONT>
<P><FONT SIZE=3>  add byte _a,al</FONT>
<P><FONT SIZE=3>  add al,byte _a</FONT>
<P><FONT SIZE=3>  add ax,1</FONT>
<P><FONT SIZE=3>  add word _a,1</FONT>
<P><FONT SIZE=3>  add byte _a,1</FONT>
<BR>
<P><FONT SIZE=3><B>  5.7 and(수치 데이터와 레지스터 또는 메모리 위치를 AND연산한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  8비트 또는 16비트 연산을 하며, 베이스 메모리/레지스터로 지정한 메모리 위치 또는 레지스터    와 데이터를 비트 단위로 AND하여 베이스 메모리/레지스터로 지정한 위치에 저장한다.</FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[사용예]</FONT>
<P><FONT SIZE=3>  and ax,bx</FONT>
<P><FONT SIZE=3>  and ah,bh</FONT>
<P><FONT SIZE=3>  and word _a,ax</FONT>
<P><FONT SIZE=3>  and ax,word _a</FONT>
<P><FONT SIZE=3>  and byte _a,al</FONT>
<P><FONT SIZE=3>  and al,byte _a</FONT>
<P><FONT SIZE=3>  and ax,1</FONT>
<P><FONT SIZE=3>  and word _a,1</FONT>
<P><FONT SIZE=3>  and byte _a,1</FONT>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제6장 c???? 명령어</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 6 장 c???? 명령어</FONT>
<BR>
<P><FONT SIZE=3><B>  6.1 cbw(al 레지스터의 부호를 ah 레지스터에 16 진수로 저장한다)</B></FONT>
<BR>
<P><FONT SIZE=3>  [기능]</FONT>
<P><FONT SIZE=3>  al 레지스터의 비트 7 의 내용이 1 이면 ah 레지스터에 0xff 를 저장하고, al 레지스터의 비트    7 의 내용이 0 이면 ah 레지스터에 0 을 저장한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  cbw</FONT>
<BR>
<P><FONT SIZE=3><B>  6.2 clc(캐리 플래그를 클리어시켜 준다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  캐리 플래그가 1 이면 0 으로 클리어 시켜준다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  clc</FONT>
<BR>
<P><FONT SIZE=3><B>  6.3 cld(디랙션 플래그를 클리어한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  디랙션 플래그를 0 으로 변환시킨다.  이것은 스트링 연산이 스트링 연산에 의해 사용되는 포    인터상에 자동 증가를 행하는것과 같은 효과가 있다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  cld</FONT>
<BR>
<P><FONT SIZE=3><B>  6.4 cli(인터럽트가 걸리는 것을 막아 준다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  인터럽트 플래그를 설정한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  cli</FONT>
<BR>
<P><FONT SIZE=3><B>  6.5 cmc(캐리 플래그를 반전시킨다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  캐리 플래그를 원래의 상태로 바꾸어 놓는다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  cmc</FONT>
<BR>
<P><FONT SIZE=3><B>  6.6 cmpsb(메모리와 메모리를 바이트대 바이트로 비교한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  SI 레지스터에 의해 지정된 메모리의 내용과 DI 레지스터에 의해 지정된 메모리 위치의 내용을    비교하는 것으로, DI 레지스터에 으해 지정된 메로리의 내용에서 SI 레지스터에 의해 지정된     메모리 위치의 내용을 뺀 결과에 따라 플래그 레지스터에 변화를 주고, 이때 SI 와 DI 는 방향    플래그의 내용에 따라 증가한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  cmpsb</FONT>
<BR>
<P><FONT SIZE=3><B>  6.7 cmpsw(메모리와 메모리를 워드대 워드로 비교한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  데이타를 워드로 비교하고 기능은 cmpab와 같음</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  cmpsw</FONT>
<BR>
<P><FONT SIZE=3><B>  6.8 cs:(데이타 참조를 CS 레지스터로 한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  데이타 참조를 DS 레지스터에서 CS 레지스터로 변경한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  cs:</FONT>
<BR>
<P><FONT SIZE=3><B>  6.9 cwd(ax 레지스터의 부호를 dx 레지스터에 16 진수로 저장한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  ax 레지스터의 비트 15 의 내용이 1 인 경우 dx 레지스터에 0xffff 를 저장 시키고, ax 레지스    터의 비트 15 내용이 0 인 경우 dx 레지스터에 0x0000 를 저장시킨다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  cwd</FONT>
<BR>
<P><FONT SIZE=3><B>  6.10 call(서브 루틴을 호출한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  지정된 번지로 near call 혹은 far call을 한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3><B>  </B>call near &amp;start       ; start레이블 번지로 call</FONT>
<P><FONT SIZE=3>  call</FONT>	<FONT SIZE=3>near ax          ; ax 레지스터의 값으로 call</FONT>
<BR>
<P><FONT SIZE=3>  call</FONT>	<FONT SIZE=3>near [bx]        ; 베이스 메모리 [bx] 으로 call</FONT>
<BR>
<P><FONT SIZE=3>  call</FONT>	<FONT SIZE=3>near [&amp;start]    ; start 번지의 내용을 변위로  call ---+ 같은 코드</FONT>
<P><FONT SIZE=3>  call</FONT>	<FONT SIZE=3>near _start      ; start 번지의 내용으로 call       ---+</FONT>
<BR>
<P><FONT SIZE=3>  call far 0x1234,0xabcd ; 0x1234:0xabcd로 call</FONT>
<P><FONT SIZE=3>  call far [bx]          ; 베이스 메모리 [bx]를 far call </FONT>
<BR>
<P><FONT SIZE=3><B>  6.11 cmp(데이터의 비교)</B></FONT>
<BR>
<P><FONT SIZE=3>  [기능]</FONT>
<P><FONT SIZE=3>  1오퍼랜드와 2오퍼랜드를 비교하여 플래그를 변화시킨다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  cmp ax,bx</FONT>
<P><FONT SIZE=3>  cmp ah,bh</FONT>
<P><FONT SIZE=3>  cmp word _a,ax</FONT>
<P><FONT SIZE=3>  cmp ax,word _a</FONT>
<P><FONT SIZE=3>  cmp byte _a,al</FONT>
<P><FONT SIZE=3>  cmp al,byte _a</FONT>
<P><FONT SIZE=3>  cmp ax,1</FONT>
<P><FONT SIZE=3>  cmp word _a,1</FONT>
<P><FONT SIZE=3>  cmp byte _a,1</FONT>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제7장 d?? 명령어</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 7 장 d?? 명령어</FONT>
<BR>
<P><FONT SIZE=3><B>  7.1 daa(덧셈을 한 후에 ax 레지스터에서 10진 변환을 한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  두 개의 BCD 수를 더한 후에만 사용하는 것으로, AF 플래그가 1이거나 al 레지스터의 하위 4     비트의 내용이 0x0a - 0x0f 이면 al 레지스터 내용에 0x06 를 더하고 AF 플래그를 1 로 한다.    만약 CF 플래그가 1 또는 al 레지스터의 상위 4 비트의 내용이 9보다 크면 al 레지스터의 내용    에 0x60를 더한 후 CF 플래그를 1로 한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  daa</FONT>
<BR>
<P><FONT SIZE=3><B>  7.2 das(뺄샘을 한 후에 ax 레지스터에서 10진 변환을 한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능] </FONT>
<P><FONT SIZE=3>  2 개의 BCD 수를 가지고 뺄샘한 후에만 사용되며, AF 플래그가 1 이거나 al 레지스터의 하위 4    비트가 0x0a - 0x0f 이면 al 레지스터의 내용에 0x06를 뺀 후 AF 플래그를 1로 하고, CF 플래    그가 1이거나 al 레지스터의 상위 4 비트 내용이 9 보다 크면 al 레지스터의 내용에서 0x60를    뺀 후 CF 플래그를 1로 한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  das</FONT>
<BR>
<P><FONT SIZE=3><B>  7.3 ds:(데이타 참조 세그먼트를 DS 레지스터로 한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  데이타 참조 세그먼트 레지스터를 DS 로 한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  ds:</FONT>
<BR>
<P><FONT SIZE=3><B>  7.4 dec(레지스터 혹은 메모리를 감소 시킨다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  베이스 메모리 혹은 레지스터의 내용을 하나 감소 시킨다.  세그먼트 레지스터는 안된다</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  dec ax</FONT>
<P><FONT SIZE=3>  dec al</FONT>
<P><FONT SIZE=3>  dec byte _data</FONT>
<P><FONT SIZE=3>  dec word _data</FONT>
<P><FONT SIZE=3>  </FONT>
<P><FONT SIZE=3><B>  7.5 div(ah : al 혹은 dx : ax 레지스터를 레지스터 또는 메모리 위치로 나눈다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  이 명령어는 16비트 부호없는 수를 8 비트 부호없는 수로 나누거나, 32비트 부호없는 수를 16    비트 부호없는 수로 나누는 경우에 사용되며, 8 비트 연산인 경우, ax 레지스터의 내용을 베이    스메모리/레지스터로 지정한 위치의 내용으로 나눈 8비트 몫은 al 레지스터에 저장하고, 8 비    트 나머지는 ah 레지스터에 저장한 수, al 레지스터의 내용이 0xff 보다 크면 Type 0 인터럽트    가 발생한다.  16 비트 연산인 경우, 16비트 몫은 ax 레지스터에 저장되고, 16 비트 나머지는    dx 레지스터에 저장된다.  이 때, ax 레지스터에 저정된 몫이 0xffff 보다 크면 Type 0 인터럽    트가 발생한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  div bl</FONT>
<P><FONT SIZE=3>  div bx</FONT>
<P><FONT SIZE=3>  div si</FONT>
<P><FONT SIZE=3>  div byte _data</FONT>
<P><FONT SIZE=3>  div word _data</FONT>
<BR>
<P><FONT SIZE=3><B>  7.6 db(1바이트의 자료를 선언한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  바이트의 데이타를 선언한다.  이 명령어는 기계어로 변환되지 않고 어셈블러에게 지시만 지시    한다.  'db' 선언뒤에는 오직 1바이트의 자료만 선언할수 있다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  !NULL   0</FONT>
<BR>
<P><FONT SIZE=3>  _data db 0</FONT>
<P><FONT SIZE=3>        db 0xff</FONT>
<P><FONT SIZE=3>        db 0b11110000</FONT>
<P><FONT SIZE=3>        db 'a'</FONT>
<P><FONT SIZE=3>        db "b"</FONT>
<P><FONT SIZE=3>        db '\r'</FONT>
<P><FONT SIZE=3>        db "\n"</FONT>
<P><FONT SIZE=3>        db !NULL</FONT>
<BR>
<P><FONT SIZE=3><B>  7.7 ds(문자열 자료를 선언한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  문자열 데이타를 선언한다.  GA 에서 문자열이란 3바이트 이상의 자료를 말한다.  이 명령어는    기계어로 변환되지 않고 어셈블러에게 지시만 한다.  2 이바이트 이하 자료선언시 오류를 표     시할 것이다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _data ds 'abcd'</FONT>
<P><FONT SIZE=3>        ds "abcd"</FONT>
<P><FONT SIZE=3>        ds 'Korea\r\n'</FONT>
<P><FONT SIZE=3>        ds "Korea\r\n"</FONT>
<BR>
<P><FONT SIZE=3><B>  7.8 du(확보형 자료를 선언한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  같은 종류의 자료를 확보한다.  문법은 'du' size,character 이다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  !ESC  8</FONT>
<BR>
<P><FONT SIZE=3>  _data du 10</FONT>
<P><FONT SIZE=3>        du 0x10</FONT>
<P><FONT SIZE=3>        du 0b00001000</FONT>
<P><FONT SIZE=3>        du 10,'a'</FONT>
<P><FONT SIZE=3>        du 10,'b'</FONT>
<P><FONT SIZE=3>        du 10,!ESC</FONT>
<BR>
<P><FONT SIZE=3><B>  7.9 dw(2바이트 자료를 선언한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  2 바이트 데이타를 선언한다.  이 명령어는 기계어로 변환되지 않고 어셈블러에게 지시만 지시    한다.  'dw' 선언뒤에는 오직 2 바이트의 자료만 선언할수 있다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  !NULL   0</FONT>
<BR>
<P><FONT SIZE=3>  _data dw 0</FONT>
<P><FONT SIZE=3>        dw 0xffff</FONT>
<P><FONT SIZE=3>        dw 0b11110000</FONT>
<P><FONT SIZE=3>        dw 'ab'</FONT>
<P><FONT SIZE=3>        dw "bc"</FONT>
<P><FONT SIZE=3>        dw '\r\n'</FONT>
<P><FONT SIZE=3>        dw "\n\r"</FONT>
<P><FONT SIZE=3>        dw !NULL</FONT>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제8장 e?? 명령어</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 8 장 e?? 명령어</FONT>
<BR>
<P><FONT SIZE=3><B>  8.1 es:(데이타 지정을 es 레지스터로 한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  베이스 메모리 데이타 참조 세그먼트를 엑스트라 세그먼트로(es)로 한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  es:</FONT>
<BR>
<P><FONT SIZE=3><B>  8.2 esc(8087로 커맨드와 데이타를 보낸다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  8087 소수점 연산을 할때 사용한다</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  GA는 부동소수점 연산 명령을 지원하지 안는다.  따라서 소스 화일에 esc 명령어를 사용하면     아래와 같은 경고 메시지가 표시된다.</FONT>
<BR>
<P><FONT SIZE=3><B>  </B>Warning(6) : 'esc' opcode not supply</FONT>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제9장 h?? 명령어</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 9 장 h??? 명령어</FONT>
<BR>
<P><FONT SIZE=3><B>  9.1 hlt(인터럽트가 걸릴 때까지 CPU 를 정지기킨다)</B></FONT>
<BR>
<P><FONT SIZE=3>  [기능]</FONT>
<P><FONT SIZE=3>  프로그램의 샐행이 중단된다.  이것은 외부 인터럽트 또는 restart 실행에 의한 RESET 을 요구    하는 경우다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  hlt</FONT>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제10장 i??? 명령어</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 10 장 i??? 명령어</FONT>
<BR>
<P><FONT SIZE=3><B>  10.1 into(오버플로우 플래그가 세트되어 있을 때에만 INT 4 를 발생시킨다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  인터럽트 4번를 발생&#44987;킨다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  into</FONT>
<BR>
<P><FONT SIZE=3><B>  10.2 iret(인터럽트 처리 루틴으로부터 복귀한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  인터럽트 처리 루틴에서 복귀한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  iret</FONT>
<BR>
<P><FONT SIZE=3><B>  10.3 int(소프트 웨어 인터럽트를 발생시킨다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  인터럽트 백터의 번지를 참조하여 소프트웨어 인터럽트를 발생시킨다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  int 1</FONT>
<P><FONT SIZE=3>  int 3</FONT>
<P><FONT SIZE=3>  int !MSDOSint</FONT>
<P><FONT SIZE=3>  int 0xff</FONT>
<BR>
<P><FONT SIZE=3><B>  10.4 inc(레지스터 또는 메모리 위치를 증가시킨다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  베이스 메모리 혹은 레지스터의 내용을 1 증가시킨다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  inc al</FONT>
<P><FONT SIZE=3>  inc ax</FONT>
<P><FONT SIZE=3>  inc byte _data</FONT>
<P><FONT SIZE=3>  inc word _data</FONT>
<BR>
<P><FONT SIZE=3><B>  10.5 imul(부호있는 곱셈을 한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  바이트 데이터의 경우, al 레지스터에 1오퍼랜드를 곱하여 ax 레지스터에 넣는다.  데이터는     부호가 있다.  워드 데이터의 경우, ax 레지스터에 1오퍼랜드를 곱하여 dx : ax 레지스터에 넣    는다.  데이터는 부호있음이다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  imul bl</FONT>
<P><FONT SIZE=3>  imul bx</FONT>
<P><FONT SIZE=3>  imul si</FONT>
<P><FONT SIZE=3>  imul byte _data</FONT>
<P><FONT SIZE=3>  imul word _data</FONT>
<BR>
<P><FONT SIZE=3><B>  10.6 idiv(부호있는 나눗셈을 한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  바이트 데이터의 경우 ax 레지스터에 1오퍼랜드를 나누어 몫을 al, 나머지를 ah 레지스터에 넣    는다.  워드 데이터의 경우 dx : ax 에 1오퍼랜드를 나누어 몫을 ax, 나머지를 dx 레지스터에    넣는다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  idiv bl</FONT>
<P><FONT SIZE=3>  idiv bx</FONT>
<P><FONT SIZE=3>  idiv si</FONT>
<P><FONT SIZE=3>  idiv byte _data</FONT>
<P><FONT SIZE=3>  idiv word _data</FONT>
<BR>
<P><FONT SIZE=3><B>  10.7 in(입출력 포트로부터 al 혹은 ax 레지스터에 데이터를 받는다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  입출력 표트로부터 al 혹은 ax 레지스터에 데이터를 받는다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  in al,0</FONT>
<P><FONT SIZE=3>  in al,!NULL</FONT>
<P><FONT SIZE=3>  in ax,0xff</FONT>
<P><FONT SIZE=3>  in ax,!NULL</FONT>
<BR>
<P><FONT SIZE=3>  in al,dx</FONT>
<P><FONT SIZE=3>  in ax,dx</FONT>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제11장 j??? 명령어</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 11 장 j??? 명령어</FONT>
<BR>
<P><FONT SIZE=3><B>  11.1 jb/jnae(작으면 점프한다/같거나 크지않으면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  캐리 플래그가 1이면 변위가 지정하는 위치로 점프하고, 캐리 플래그가 0이면 jb/jnae 다음의    오는 명령어를 실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jb short &amp;start</FONT>
<P><FONT SIZE=3>  jnae short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.2 jbe/jna(같거나 작으면 점프한다/크지않으면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  캐리 플래그 또는 제로 플래그가 1이면 변위가 지정하는 위치로 점프하고 0이면 다음 명령어를    실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jbe short &amp;start</FONT>
<P><FONT SIZE=3>  jna short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.3 jcxz(cx 레지스터가 0이면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  cx 레지스터의 내용이 0이면 변위가 지정하는 위치로 점프하고, 그렇지 않으면 다음 명령어를    실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jcxz short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.4 je/jz(0이면 점프한다/같으면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  제로 플래그가 1이면 변위가 지정하는 위치로 점프하고, 제로 플래그가 0이면 다음 명령어를     실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  je short &amp;start</FONT>
<P><FONT SIZE=3>  jz short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.5 jl/jnge(작으면 점프한다/크지 않거나 같으면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  사인 플래그와 초과 플래그가 같지 않으면 변위가 지정하는 위치로 점프하고, 같으면 다음 명    령어를 실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jl short &amp;start</FONT>
<P><FONT SIZE=3>  jnge short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.6 jle/jng(작거나 같으면 점프한다/크지 않으면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  제로 플래그가 1이거나 사인 플래그가 오버 플래그와 다른 경우에 변위 위치로 점프 하고, 그    렇지 않으면 다음 명령어를 실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jle short &amp;start</FONT>
<P><FONT SIZE=3>  jng short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.7 jnb/jae(작지 않으면 점프한다/같거나 크면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  캐리 플래그가 0이면 변위가 가리키는 위치로 점프한다.  그렇지 않으면 다음 명령어를 실행한    다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jnb short &amp;start</FONT>
<P><FONT SIZE=3>  jae short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.8 jnbe/ja(크거나 같으면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  캐리와 제로 플래그의 내용이 제로가 아니면 상대적으로 변위 위치로 점프한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jnbe short &amp;start</FONT>
<P><FONT SIZE=3>  ja short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.9 jne/jnz(같지 않으면 점프한다/0 이 아니면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  제로 플래그가 0 이면 변위가 지정하는 위치로 점프하고, 제로 플래그가 1이면 다음 명령어를    실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jne short &amp;start</FONT>
<P><FONT SIZE=3>  jnz short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.10 jnl/jnle(크면 점프한다/작지 않거나 같지 않으면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  사인 플래그와 오버 플래그가 같으면 변위가 지정하는 위치로 점프하고, 같지 않으면 다음 명    령어를 실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jnl short &amp;start</FONT>
<P><FONT SIZE=3>  jnle short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.11 jge(부호가 있고 이상이면 분기한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  크거나 같으면 점프한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jge short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.12 jg/jnle(크면 점프한다/작지 않거나 같지 않으면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  제로 플래그가 0이고 사인 플래그가 오버 플래그와 같은 경우에는 변위가 가리키는 위치로 점    프하고, 그렇지 않으면 다음 명령어를 실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jg short &amp;start</FONT>
<P><FONT SIZE=3>  jnle short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.13 jno(오버플로우가 일어나지 않으면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  오버 플래그가 0이면 변위가 가리키는 위치로 점프하고, 오버플래그가 1이면 다음 명령어를 실    행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jo short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.14 jnp/jpo(패리티가 0이면 점프한다/패리티가 1이면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  패리티 플래그가 0이면 변위가 가리키는 위치로 점프, 패리티가 1이면 다음 명령어를 실행한     다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jnp short &amp;start</FONT>
<P><FONT SIZE=3>  jpo short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.15 jns(사인 비트가 0이면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  사인 플래그가 0이면 변위 위치로 점프, 사인 플래그가 1이면 다음 명령어를 실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jns short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.16 jo(오버플로우이면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  오버 플래그가 1이면 변위 위치로 점프, 오버 플래그가 1이 아니면 다음 명령어를 실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jo short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.17 jp/jpe(패리티가 0이면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  패리티 플래그가 1이면 변위 위치로 점프하고, 패리티가 0이면 다음 명령어를 실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  jp short &amp;start</FONT>
<P><FONT SIZE=3>  jpe short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.18 js(사인 비트가 1이면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  사인 플래그가 1이면 변위 위치로 점프 사인 플래그가 0이면 다음 명령어를 실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  js short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  11.19 jmp(오퍼 랜드가 지정된 곳으면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  IP(Instruction Pointer : 명령 포인터)를 변경하여 변위로 지정된 위치에 무조건 분기한다.</FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[사용예]</FONT>
<P><FONT SIZE=3>  jmp near &amp;start       ; start레이블 번지로 점프</FONT>
<P><FONT SIZE=3>  jmp near ax           ; ax 레지스터의 값으로 점프</FONT>
<BR>
<P><FONT SIZE=3>  jmp near [bx]         ; 베이스 메모리 [bx] 으로 점프</FONT>
<BR>
<P><FONT SIZE=3>  jmp near [&amp;start]     ; start 번지의 내용을 변위로  점프 ---+ 같은 코드</FONT>
<P><FONT SIZE=3>  jmp near _start       ; start 번지의 내용으로 점프       ---+</FONT>
<BR>
<P><FONT SIZE=3>  jmp far 0x1234,0xabcd ; 0x1234:0xabcd로 점프</FONT>
<P><FONT SIZE=3>  jmp far [bx]          ; 베이스 메모리 [bx]를 far 점프 </FONT>
<BR>
<P><FONT SIZE=3>  </FONT>
<TABLE BORDER=1 CELLPADDING=2 WIDTH=593 HEIGHT=247>
<TD VALIGN=TOP ROWSPAN=2 WIDTH=13%>
<BR>
<P><FONT SIZE=3>A,B의 대소 관계</FONT>
<BR></TD>
<TD VALIGN=TOP ROWSPAN=2 WIDTH=17%>
<BR>
<P><FONT SIZE=3>부호없는 숫자의 경우</FONT></TD>
<TD VALIGN=TOP COLSPAN=2 WIDTH=28%>
<P><FONT SIZE=3>조건을 만족하는 플래그의 상태</FONT></TD>
<TD VALIGN=TOP ROWSPAN=2 WIDTH=18%>
<BR>
<P><FONT SIZE=3>부호가 있는 숫자의 경우</FONT></TD>
<TD VALIGN=MIDDLE COLSPAN=2 WIDTH=22%>
<P><FONT SIZE=3>조건을 만족하는 플래그의 상태</FONT></TD>
<TR>
<TD VALIGN=MIDDLE WIDTH=14%>
<P><FONT SIZE=3>   CF</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=14%>
<P><FONT SIZE=3>   ZF</FONT></TD>
<TD VALIGN=MIDDLE WIDTH=14%>
<P><FONT SIZE=3>  SF&#8853;OF</FONT></TD>
<TD VALIGN=TOP WIDTH=8%>
<P><FONT SIZE=3> ZF</FONT></TD>
<TR>
<TD VALIGN=TOP WIDTH=13%>
<P><FONT SIZE=3> A &gt; B</FONT>
<P><FONT SIZE=3> A &gt;=B</FONT>
<P><FONT SIZE=3> A = B</FONT>
<P><FONT SIZE=3> A &lt;=B</FONT>
<P><FONT SIZE=3> A &lt; B</FONT>
<P><FONT SIZE=3> A &#8800; B</FONT></TD>
<TD VALIGN=TOP WIDTH=17%>
<P><FONT SIZE=3>  JA/JNBE</FONT>
<P><FONT SIZE=3>  JNB/JAE</FONT>
<P><FONT SIZE=3>  JZ/JE</FONT>
<P><FONT SIZE=3>  JBE/JNA</FONT>
<P><FONT SIZE=3>  JB/JNAE</FONT>
<P><FONT SIZE=3>  JNZ/JNE</FONT></TD>
<TD VALIGN=TOP WIDTH=14%>
<P><FONT SIZE=3>    0</FONT>
<P><FONT SIZE=3>    0</FONT>
<P><FONT SIZE=3>   ×</FONT>
<P><FONT SIZE=3>    1</FONT>
<P><FONT SIZE=3>    1</FONT>
<P><FONT SIZE=3>   ×</FONT></TD>
<TD VALIGN=TOP WIDTH=14%>
<P><FONT SIZE=3>    0</FONT>
<P><FONT SIZE=3>   ×</FONT>
<P><FONT SIZE=3>    1</FONT>
<P><FONT SIZE=3>    1</FONT>
<P><FONT SIZE=3>   ×</FONT>
<P><FONT SIZE=3>    0</FONT></TD>
<TD VALIGN=TOP WIDTH=18%>
<P><FONT SIZE=3>  JG/JNLE</FONT>
<P><FONT SIZE=3>  JGE/JNL</FONT>
<P><FONT SIZE=3>  JZ/JE</FONT>
<P><FONT SIZE=3>  JLE/JNG</FONT>
<P><FONT SIZE=3>  JL/JNGE</FONT>
<P><FONT SIZE=3>  JNZ/JNE</FONT></TD>
<TD VALIGN=TOP WIDTH=14%>
<P><FONT SIZE=3>    0</FONT>
<P><FONT SIZE=3>    0</FONT>
<P><FONT SIZE=3>   ×</FONT>
<P><FONT SIZE=3>    1</FONT>
<P><FONT SIZE=3>    1</FONT>
<P><FONT SIZE=3>   ×</FONT></TD>
<TD VALIGN=TOP WIDTH=8%>
<P><FONT SIZE=3>  0</FONT>
<P><FONT SIZE=3> ×</FONT>
<P><FONT SIZE=3>  1</FONT>
<P><FONT SIZE=3>  1</FONT>
<P><FONT SIZE=3> ×</FONT>
<P><FONT SIZE=3>  0</FONT></TD>
<CAPTION ALIGN=BOTTOM>
</CAPTION>

</TABLE>
<BR>
<BR>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제12장 l????? 명령어</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 12 장 l????? 명령어</FONT>
<BR>
<P><FONT SIZE=3><B>  12.1 lahf(플래그 레지스터의 하위 8비트를 ah 레지스터에 복사한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  플래그 레지스터의 하위 8비트를 ah 레지스터에 복사한다</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  lahf</FONT>
<BR>
<P><FONT SIZE=3><B>  12.2 lock(다음 명령어의 버스 사용권을 확보한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  다음 명령어의 버스 사용권을 확보한다</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  lock</FONT>
<BR>
<P><FONT SIZE=3><B>  12.3 lodsb(메모리에서 al 레지스터로 로드한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  si 레지스터로 지정한 메모리 위치의 내용로 이동시킨 후, si 레지스터는 DF 플래그의 값에 따    라 증가 또는 감소한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  lodsb</FONT>
<BR>
<P><FONT SIZE=3><B>  12.4 lodsw(메모리에서 ax 레지스터로 로드한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  ax 레지스터로 지정한 메모리 위치의 내용을 이동시킨 후, si 레지스터는 DF 플래그의 값에 따    라 증가 또는 감소한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  lodsw</FONT>
<BR>
<P><FONT SIZE=3><B>  12.5 loop(cx 레지스터를 감소시키고, 0 이 아니면 점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  cx 레지스터 내용을 1 감소기켜 cx 레지스터 내용이 0 이 되면 변위 위치로 점프하고, 0 아니    면 다음 명령어를 실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  loop short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  12.6 loopnz/loopne(cx 레지스터를 감소기키고, cx 가 0이 아니고 제로 플래그가 0 이면    점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  cx 레지스터의 내용을 감소시켜 0 이 되고, 제로 플래그가 0이면 변위 위치로 점프하고, 그렇    지 않으면 다음 명령어를 실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  _start</FONT>
<P><FONT SIZE=3>  loopnz short &amp;start</FONT>
<P><FONT SIZE=3>  loopne short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  12.7 loopz/loope(cx 레지스터를 감소시키고, cx 레지스터가 0이고 제로 플래그가 1 이면    점프한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  cx 레지스터 내용을 감소시켜 0이 되지 않고, 제로 플래그가 1 이면 변위 위치로 점프하고, 그    렇지 않으면 다음 명령어를 실행한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>   _start</FONT>
<P><FONT SIZE=3>  loopz short &amp;start</FONT>
<P><FONT SIZE=3>  loope short &amp;start</FONT>
<BR>
<P><FONT SIZE=3><B>  12.8 lds(데이타 세그먼트 레지스터(ds)를 참조하여 데이타를 1오퍼랜드의 16 비트 레지    스터에 저장한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  데이타 세그먼트 레지스터(ds)를 참조하여 데이타를 1오퍼랜드의 16 비트 레지스터에 저장 한    다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  lds ax,far _data</FONT>
<P><FONT SIZE=3>  lds si,far _data</FONT>
<BR>
<P><FONT SIZE=3><B>  12.9 les(엑스트라 세그먼트 레지스터(es)를 참조하여 데이타를 1오퍼랜드의 16 비트 레    지스터에 저장한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  엑스트라 세그먼트 레지스터(es)를 참조하여 데이타를 1오퍼랜드의 16 비트 레지스터 에         저장한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  les ax,far _data</FONT>
<P><FONT SIZE=3>  les si,far _data</FONT>
<BR>
<P><FONT SIZE=3><B>  12.10 lea(2오퍼랜드의 실효 번지를 로드한다)</B></FONT>
<BR>
<P><FONT SIZE=3>  [기능]</FONT>
<P><FONT SIZE=3>  2오퍼랜드의 실효 번지를 로드한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  lea ax,near _data</FONT>
<BR>
<P><FONT SIZE=3>  +-- 참고 ----------------------------------------------+</FONT>
<P><FONT SIZE=3>  | 위&#50049; 코드는 다음의 코드와 같다                       |</FONT>
<P><FONT SIZE=3>  |                                                      |</FONT>
<P><FONT SIZE=3>  | mov ax,&amp;data                                         |</FONT>
<P><FONT SIZE=3>  |                                                      |</FONT>
<P><FONT SIZE=3>  +------------------------------------------------------+</FONT>
<BR>
<BR>
<BR>
<BR>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제13장 m??? 명령어</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 13 장 m??? 명령어</FONT>
<BR>
<P><FONT SIZE=3>  <B>13.1 movsb(메모리로부터 바이트 데이타로 옮겨진다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  si 레지스터로 지정된 메모리 위치의 내용을 di 레지스터로 지정된 메모리 위치로 옮겨 놓고,    si 화 di 레지스터의 내용을 DF 플래그의 값에 따라 증가 또는 감소시킨다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  movsb</FONT>
<BR>
<P><FONT SIZE=3><B>  13.2 movsw(메모리로부터 워드 데이타로 옮겨진다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  si 레지스터로 지정된 메모리 위치의 내용을 di 레지스터로 지정된 메모리 위치로 옮겨 놓고,    si 화 di 레지스터의 내용을 DF 플래그의 값에 따라 증가 또는 감소시킨다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  movsw</FONT>
<BR>
<P><FONT SIZE=3><B>  13.3 mul(레지스터 또는 메모리 위치와 al 또는 ax 레지스터롤 곱한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  베이스 메모리 혹은 레지스터로 지정한 메모리 위치 또는 레지스터의 내용과, 8비트인 경우는    al 레지스터, 16 비트 연산인 경우에는 ax 레지스터의 내용을 곱하여 al 또는 ax 에 기억시킨    다.  이 때, 8비트 연산 이라면 al 레지스터의 하위 8비트 결과를 기억시키고, 결과인 상위 8    비트 내용은 ah 레지스터에 기억시킨다.  만약 16비트 연산을 실행시키면 결과인 하위 16비트    는 ax 레지스터에 기억시키고, 결과인 상위 16 비트 결과는 dx 레지스터에 기억시킨다.  또한,    8비트 또는 16비트 연산 모두 상위 4비트의 결과가 0이 라면 오버플로우 플래그와 캐리 플래     그는 0이 되고, 0이 아니면 1이 된다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  mul bl</FONT>
<P><FONT SIZE=3>  mul bx</FONT>
<P><FONT SIZE=3>  mul si</FONT>
<P><FONT SIZE=3>  mul byte _data</FONT>
<P><FONT SIZE=3>  mul word _data</FONT>
<BR>
<P><FONT SIZE=3><B>  13.4 mov(2오퍼랜드의 내용을 1오퍼랜에 전송한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  2오퍼랜드의 내용을 1오퍼랜드에 전송하며, 세그먼트 레지스터를 사용할수 있다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  mov ax,bx</FONT>
<P><FONT SIZE=3>  mov ah,bh</FONT>
<P><FONT SIZE=3>  mov word _a,ax</FONT>
<P><FONT SIZE=3>  mov ax,word _a</FONT>
<P><FONT SIZE=3>  mov byte _a,al</FONT>
<P><FONT SIZE=3>  mov al,byte _a</FONT>
<P><FONT SIZE=3>  mov ax,1</FONT>
<P><FONT SIZE=3>  mov word _a,1</FONT>
<P><FONT SIZE=3>  mov byte _a,1</FONT>
<BR>
<P><FONT SIZE=3>  ;세그먼트 레지스터를 사용한 경우</FONT>
<P><FONT SIZE=3>  mov ax,ds</FONT>
<P><FONT SIZE=3>  mov word _data,ds</FONT>
<P><FONT SIZE=3>  mov es,ax</FONT>
<P><FONT SIZE=3>  mov es,word _data</FONT>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제14장 n?? 명령어</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 14 장 n?? 명령어</FONT>
<BR>
<P>	<FONT SIZE=3>  "nop","neg","not",NULL</FONT>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제15장 o?? 명령어</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 15 장 o?? 명령어</FONT>
<BR>
<P><FONT SIZE=3><B>  15.1 org(프로그램 번지를 세팅한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  GA는 *.COM 형식의 실행화일을 출력한다.  여기서 실행화일은 PSP(Program Segment Prefix) 다    음에 위치하게 된다.  여기서 소스화일의 시작번지를 0x100번지로 마추어야 한다.  *.COM 형식    의 실행화일은 시작번지의 제약이 있다.  'org'명령은 어셈블러에게 지시해주는 명령으로 org    다음에 수치를 지정한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  org 0x100</FONT>
<P><FONT SIZE=3>  org !START_add</FONT>
<BR>
<P><FONT SIZE=3><B>  15.2 or(OR 명령을 한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  al(8 비트 연산인 경우) 또는 ax (16비트 연산인 경우) 레지스터의 내용과 데이터를 비트별로    OR 시켜, 결과를 al 또는 ax 에 저장한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  or ax,bx</FONT>
<P><FONT SIZE=3>  or ah,bh</FONT>
<P><FONT SIZE=3>  or word _a,ax</FONT>
<P><FONT SIZE=3>  or ax,word _a</FONT>
<P><FONT SIZE=3>  or byte _a,al</FONT>
<P><FONT SIZE=3>  or al,byte _a</FONT>
<P><FONT SIZE=3>  or ax,1</FONT>
<P><FONT SIZE=3>  or word _a,1</FONT>
<P><FONT SIZE=3>  or byte _a,1</FONT>
<BR>
<P><FONT SIZE=3><B>  15.3 out(입출력 포트에 데이터를 보&#37000;다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  입출력 포트에 데이터를 보낸다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  out 0,al</FONT>
<P><FONT SIZE=3>  out !NULL,al</FONT>
<P><FONT SIZE=3>  out 0xff,ax</FONT>
<P><FONT SIZE=3>  out !NULL,ax</FONT>
<BR>
<P><FONT SIZE=3>  out dx,al</FONT>
<P><FONT SIZE=3>  out dx,ax</FONT>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제16장 p??? 명령어</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 16 장 p??? 명령어</FONT>
<BR>
<P><FONT SIZE=3>char *a_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "aaa","aas","aad","aam","adc","add","and",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *c_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "cbw","clc","cld","cli","cmc","cmpsb",</FONT>
<P>	<FONT SIZE=3>  "cmpsw","cs:","cwd","call","cmp",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *d_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "daa","das","ds:","dec","div","db","ds","du","dw",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *e_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "es:","esc",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *h_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "hlt",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *i_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "into","iret","int","inc","imul","idiv","in",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *j_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "jb","jnae","jbe","jna","jcxz","je","jz","jl","jnge",</FONT>
<P>	<FONT SIZE=3>  "jle","jng","jnb","jae","jnbe","ja","jne","jnz","jnl",</FONT>
<P>	<FONT SIZE=3>  "jge","jnle","jg","jno","jnp","jpo","jns","jo","jp",</FONT>
<P>	<FONT SIZE=3>  "jpe","js","jmp",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *l_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "lahf","lock","lodsb","lodsw","loop","loopnz",</FONT>
<P>	<FONT SIZE=3>  "loopne","loopz","loope","lds","lea","les",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *m_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "movsb","movsw","mul","mov",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *n_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "nop","neg","not",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *o_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "org","or","out",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *p_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "popf","pushf","pop","push",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *r_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "rep","repe","repz","repne","repnz",</FONT>
<P>	<FONT SIZE=3>  "ret","retf","rcl","rcr","rol","ror",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *s_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "sahf","scasb","scasw","stc","std","sti","stosb",</FONT>
<P>	<FONT SIZE=3>  "stosw","ss:","sal","sar","shl","shr","sbb","sub",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *t_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "test",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *w_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "wait",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<P><FONT SIZE=3>char *x_opcode[] =</FONT>
<P><FONT SIZE=3>{</FONT>
<P>	<FONT SIZE=3>  "xlat","xchg","xor",NULL</FONT>
<P><FONT SIZE=3>};</FONT>
<BR>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제22장 GA 시스템</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 22 장 GA 시스템</FONT>
<BR>
<P><FONT SIZE=3>  <B>22.1 시스템의 구조</B></FONT>
<BR>
<P><FONT SIZE=3>  GA 어셈블러 시스템의 구조는 다음과 같다.</FONT>
<BR>
<P><FONT SIZE=3>  +--------+</FONT>
<P><FONT SIZE=3>  | 초기화 |</FONT>
<P><FONT SIZE=3>  +---+----+  +---------+</FONT>
<P><FONT SIZE=3>      +-------+ 1 PASS  |</FONT>
<P><FONT SIZE=3>              +----+----+  +--------+</FONT>
<P><FONT SIZE=3>                   +-------+ 2 PASS |</FONT>
<P><FONT SIZE=3>                           +---+----+  +-------+</FONT>
<P><FONT SIZE=3>                               +-------+  종료 |</FONT>
<P><FONT SIZE=3>                                       +-------+</FONT>
<BR>
<P>	<FONT SIZE=3>&lt; GA 어셈블러의 전체 흐름도 &gt;</FONT>
<BR>
<P><FONT SIZE=3>  초기화 부분에서는 어셈블러가 작업할 화일의 오픈과 메모리 할당 그리고 옵션의 설정을 하고    1 PASS에서는 소스화일의 구문분석과 중간화일 생성 그리고 리스트 화일을(선택적) 생성한다.    2 PASS에서는 중간화일을 분석하여 기계어를 생성하고 종료에서는 화일을 닫고 메모리를 해제    한다.</FONT>
<BR>
<P><FONT SIZE=3>  GA 시스템 --+- 초기화 --+- 화일 오픈(file open)</FONT>
<P><FONT SIZE=3>              |           +- 메모리 할당(memory alloc)</FONT>
<P><FONT SIZE=3>              |           +- 옵션의 설정(option set)</FONT>
<P><FONT SIZE=3>              |</FONT>
<P><FONT SIZE=3>              +- 1 PASS --+- 구문 분석(struction alanyer)</FONT>
<P><FONT SIZE=3>              |           +- 중간화일 생성(out)</FONT>
<P><FONT SIZE=3>              |           +- 리스트 화일 생성(선택적)(list file out)</FONT>
<P><FONT SIZE=3>              |</FONT>
<P><FONT SIZE=3>              +- 2 PASS --+- 중간화일 분석</FONT>
<P><FONT SIZE=3>              |           +- 기계어 생성</FONT>
<P><FONT SIZE=3>              |</FONT>
<P><FONT SIZE=3>              +- 종료 ----+- 화일 클로즈</FONT>
<P><FONT SIZE=3>                          +- 메모리 해제</FONT>
<BR>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제21장 x??? 명령어</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 21 장 x??? 명령어</FONT>
<BR>
<P><FONT SIZE=3><B>  21.1 xlat(테이블 참조를 한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  bx 에 의해 간저지정된 번지로부터 al 바이트째의 데이터를 al 로 전송한다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  xlat</FONT>
<BR>
<P><FONT SIZE=3><B>  21.2 xchg(1오퍼랜드와 2오퍼랜드의 내용을 바꾼다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  1오퍼랜드와 2오퍼랜드의 내용을 바꾼다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  xchg ax,bx</FONT>
<P><FONT SIZE=3>  xchg ah,bh</FONT>
<P><FONT SIZE=3>  xchg word _a,ax</FONT>
<P><FONT SIZE=3>  xchg ax,word _a</FONT>
<P><FONT SIZE=3>  xchg byte _a,al</FONT>
<P><FONT SIZE=3>  xchg al,byte _a</FONT>
<P><FONT SIZE=3>  xchg ax,1</FONT>
<P><FONT SIZE=3>  xchg word _a,1</FONT>
<P><FONT SIZE=3>  xchg byte _a,1</FONT>
<BR>
<P><FONT SIZE=3><B>  21.3 xor(1오퍼랜드와 2오퍼랜드를 베타적 OR를 한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  al(8비트 연산)또는 ax(16비트 연산)의 내용과 데이터 내용을 xor 시킨 결과를 al 또는 ax 에    저장시킨다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  xor ax,bx</FONT>
<P><FONT SIZE=3>  xor ah,bh</FONT>
<P><FONT SIZE=3>  xor word _a,ax</FONT>
<P><FONT SIZE=3>  xor ax,word _a</FONT>
<P><FONT SIZE=3>  xor byte _a,al</FONT>
<P><FONT SIZE=3>  xor al,byte _a</FONT>
<P><FONT SIZE=3>  xor ax,1</FONT>
<P><FONT SIZE=3>  xor word _a,1</FONT>
<P><FONT SIZE=3>  xor byte _a,1</FONT>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제20장 w??? 명령어</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 20 장 w??? 명령어</FONT>
<BR>
<P><FONT SIZE=3><B>  20.1 wait(CPU를 정지시킨다)</B></FONT>
<BR>
<P><FONT SIZE=3>  [기능]</FONT>
<P><FONT SIZE=3>  Ready 신호가 올 때까지 CPU를 홀트(Halt, 정지) 시킨다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  wait</FONT>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제19장 t??? 명령어</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 19 장 t??? 명령어</FONT>
<BR>
<P><FONT SIZE=3><B>  19.1 test(AND 값을 플래그에 반영한다)</B></FONT>
<BR>
<P><FONT SIZE=3><B>  </B>[기능]</FONT>
<P><FONT SIZE=3>  비트 테스트(bit test)는 연산인 결과를 플래그에만 살리고 싶을 때 사용한다.  예들 들어, al    레지스터의 값이 0x30일 때 분기하고 싶을 경우, sub al, 0x30 에서 al의 값이 0인지 아닌지를    보면 0x30인지 아닌지 알 수 있다.  그러나 오리지널 al 의 값 -0x30를 하고 있기 때문에 al     값이 변하고 있다.  이러한 때 cmp al,0x30을 하며 al 레지스터의 값을 바꾸지 않고 플래그만    의 변화로 al=0x30인지 아닌지의 판정을 할 수 있다.  마찬가지로 test명령은 test 오퍼랜드1,    오퍼랜드 2의 형태로 오퍼랜드 1과 오퍼랜드 2의 and 를 취해 결과를 플래그에 반영하고, 오퍼    랜드 1및 오퍼랜드2의 값은 변하지 않는다.  test 에서는 특정의 비트가 0인지 1인지를 판정할    수 있다.</FONT>
<BR>
<P><FONT SIZE=3>  [사용예]</FONT>
<P><FONT SIZE=3>  test ax,bx</FONT>
<P><FONT SIZE=3>  test ah,bh</FONT>
<P><FONT SIZE=3>  test word _a,ax</FONT>
<P><FONT SIZE=3>  test ax,word _a</FONT>
<P><FONT SIZE=3>  test byte _a,al</FONT>
<P><FONT SIZE=3>  test al,byte _a</FONT>
<P><FONT SIZE=3>  test ax,1</FONT>
<P><FONT SIZE=3>  test word _a,1</FONT>
<P><FONT SIZE=3>  test byte _a,1</FONT>
<BR>
</HTML>
<HTML>
<HEAD>
<META NAME="GENERATOR" CONTENT="HTML document by Hwpw 96">
<TITLE>제1장 GA소개</TITLE>
</HEAD>

<A NAME="[문서의 처음]">

<P><FONT SIZE=5> 제 1 장 GoldFish Assembler</FONT>
<BR>
<P><FONT SIZE=3>  <B>1.1 GA의 개발 과정</B></FONT>
<BR>
<P><FONT SIZE=3>  GA(GoldFish Assembler version 1.1)의 개발 과정은 아래와 같다.</FONT>
<P><FONT SIZE=3>  </FONT>
<P><FONT SIZE=3>  +-- 개발 과정  -------------------------------------------------------+</FONT>
<P><FONT SIZE=3>  | TU1(Tiny Unassembler test version 1994년 5월)                       |</FONT>
<P><FONT SIZE=3>  |  |                                                                  |</FONT>
<P><FONT SIZE=3>  |  +--→ TA1(Tiny Assembler test version 1994년 9월)                  |</FONT>
<P><FONT SIZE=3>  |         |                                                           |</FONT>
<P><FONT SIZE=3>  |         +--→ GA10(GoldFish Assembler version 1.0 1995년 8월)       |</FONT>
<P><FONT SIZE=3>  |                |                                                    |</FONT>
<P><FONT SIZE=3>  |                +--→ GA(GoldFish Assembler version 1.1 1995년 9월)  |</FONT>
<P><FONT SIZE=3>  +---------------------------------------------------------------------+</FONT>
<BR>
<P><FONT SIZE=3><B>  1.1.1 TU1(Tiny Unassembler test version)</B></FONT>
<P><FONT SIZE=3>  </FONT>
<P><FONT SIZE=3>  TU1은 Intel 0x8086코드 구성 자료를 수집하면서 만들어 본 disassembler이다.  단일 세그먼     트를 사용하며 재배치를 하지 안는 COM(확장자가 COM인 파일)파일을 기준으로 만들었다.  파일    에 포함되어 있는 기계어를 표준 어셈블 형식에 따라 화면 혹은 리스트 파일에 출력할 수        있다.</FONT>
<BR>
<P><FONT SIZE=3><B>  1.1.2 TA1(Tiny Assembler test version)</B></FONT>
<BR>
<P><FONT SIZE=3>  TA1은 MS-DOS에서 재공하는 프로그램 역추적기(DEBUG.EXE)의 -a옵션과 같은 동작을 한다.        수집된 자료를 바탕으로 좀더 자료를 보강하면서 표준 어셈블러 형식으로 입력되게 만들었다.    각각의 어셈블러 명령들은 순차 적의로 한 줄씩 입력하고 마지막 줄에서 Enter를 입력하면 어    셈블된 기계어를 사용자가 정의한 파일에 기록하며 전에 파일이 있으면 Overwrite된다.</FONT>
<BR>
<P><FONT SIZE=3>  +-- 참고 ------------------------------------------------------------------------+</FONT>
<P><FONT SIZE=3>  |DEBUG.EXE를 실행하면 DEBUG.EXE의 프롬프트가 나오는데 거기서 '?'(물음표)를 입력하|</FONT>
<P><FONT SIZE=3>  |고 Enter를 입력하면 -a(Assemble)옵션과 다른 옵션의 정보를 볼 수 있다.           |</FONT>
<P><FONT SIZE=3>  +--------------------------------------------------------------------------------+</FONT>
<BR>
<P><FONT SIZE=3><B>  1.1.3 GA10(GoldFish Assembler version 1.0)</B></FONT>
<BR>
<P><FONT SIZE=3>  GA10은 텍스트 에디터(Text Editor)로 작성된 파일을 입력으로 설계되었다.  이 버전부터 어셈    블 표준 코딩 법을 따르지 안고 조금 다른 문법으로 코딩하도록 설계하였다.  따라서 이 버전    부터는 표준 어셈블러와 호환이 안된다.</FONT>
<BR>
<P><FONT SIZE=3><B>  1.1.4 GA(GoldFish Assembler version 1.1)</B></FONT>
<P><FONT SIZE=3>  </FONT>
<P><FONT SIZE=3>  GA는 GA10에서 베이스 메모리 코딩시 발생되는 문제를 해결했다. 모든 사항은 GA10과 같고       베이스 메모리에 대한 기계어코드가 같지 안다.</FONT>
<BR>
<BR>
<P><FONT SIZE=3>  +-- 참고 ------------------------------------------------------------------------------+</FONT>
<P><FONT SIZE=3>  |어셈블러는 아래와 같이 구분할수 있다.                                                 |</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  |핸드 어셈블러(Hand Assembler)                                                         |</FONT>
<P><FONT SIZE=3>  |사람이 하나하나 손으로 어셈블하는 것으로 코드의 어셈블및 번지의 계산을 사람이 직접 한 |</FONT>
<P><FONT SIZE=3>  |다.                                                                                   |</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  |인 라인 어셈블러(In Line Assembler)                                                   |</FONT>
<P><FONT SIZE=3>  |한줄 한줄 어셈블하는 것으로 사람이 어셈블을 직접하지 않지만 번지의 계산은 사람이 한다.|</FONT>
<P><FONT SIZE=3>  |(MS-DOS의 DEBUG.EXE와 TA가 여기에 해당된다.)                                          |</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  |2패스 어셈블러(2pass Assembler)                                                       |</FONT>
<P><FONT SIZE=3>  |작성된 어셈블 소스파일을 어셈블한다.  코드의 어셈블및 레이블을 사용하여 어셈블 한다.  |</FONT>
<P><FONT SIZE=3>  |(GA가 해당된다.)                                                                      |</FONT>
<P><FONT SIZE=3>  |                                                                                      |</FONT>
<P><FONT SIZE=3>  |매크로 어셈블러(Macro Assembler)                                                      |</FONT>
<P><FONT SIZE=3>  |매크로 확장을 처리하여 주는 어셈블러 이다.(Microsoft사의 MASM이나 Bolrand사의 TASM 이 |</FONT>
<P><FONT SIZE=3>  |해당된다.)                                                                            |</FONT>
<P><FONT SIZE=3>  +--------------------------------------------------------------------------------------+</FONT>
<BR>
</HTML>
